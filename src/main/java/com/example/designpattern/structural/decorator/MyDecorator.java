package com.example.designpattern.structural.decorator;

/**
 * @Author: suxun
 * @Date: 2018/12/2 18:27
 * @Description: 装饰器模式
 * 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
 * 在不改变原有对象的基础之上，将功能附加到对象上
 * 提供了比继承更有弹性的体罚方案（扩展原有对象功能）
 * 结构型
 * 适用场景：
 * 扩展一个类的功能或给一个类添加附加职责
 * 动态地 给一个对象添加功能，这些功能可以再动态的撤销
 * 继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能
 * 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果
 * 符合开闭原则
 * 缺点：
 * 会出现更多的代码，更多的类，增加复杂度
 * 动态装饰时，多层装饰时会更复杂
 * 相关设计模式
 * 装饰-动态添加方法
 * 代理模式-控制对对象的访问
 * 适配器-适配器和被适配的类实现不同的接口
 */
public class MyDecorator {
}
